/**
 * @file queue_aggregator.hpp
 * @brief Provides a templated type to aggregate queues
 */

#include <atomic>
#include <memory>
#include <optional>
#include <tuple>
#include <variant>

namespace queue_aggregator {

template <typename Q, typename Message = Q::Message, typename Tag = Q::Tag>
concept MsgQueue = requires(Q queue, Message msg, Tag tag) {
    { queue.try_send(msg) } -> std::same_as<bool>;
    { queue.try_send_from_isr(msg) } -> std::same_as<bool>;
    { queue.try_recv(&msg) } -> std::same_as<bool>;
    { queue.recv(&msg) } -> std::same_as<void>;
    { queue.has_message() } -> std::same_as<bool>;
};

// In order to provide runtime visitation on the tuple of handles,
// we utilize this helper struct...
template <size_t N>
struct send_helper {
    
    template <size_t Idx, typename QMessage, typename Message,
              typename Aggregator>
    static auto send_resolve(const Message& msg, Aggregator* handle) -> bool {
        if constexpr (std::is_same_v<
                          std::decay_t<Message>,
                          std::variant_alternative_t<N - 1, QMessage>>) {
            return handle->template send_to<Idx>(msg);
        }
        return send_helper<N - 1>::template send_resolve<Idx, QMessage>(msg,
                                                                        handle);
    }

    template <typename Message, typename Aggregator>
    static auto send(const Message& msg, size_t idx, Aggregator* handle)
        -> bool {
        using QM =
            std::variant_alternative_t<N - 1,
                                       typename Aggregator::MessageTypes>;
        if (N - 1 == idx) {
            return send_helper<Aggregator::TaskCount>::template send_resolve<
                N - 1, QM>(msg, handle);
        } else {
            return send_helper<N - 1>::send(msg, idx, handle);
        }
    }
};

/**
 * @brief Specialization of \ref send_helper for cases of N=0, in which case
 * all functions return `false` to indicate a failure to resolve.
 */
template <>
struct send_helper<0> {
    template <size_t Idx, typename QMessage, typename Message,
              typename Aggregator>
    static auto send_resolve(const Message& msg, Aggregator* handle) -> bool {
        return false;
    }

    template <typename Message, typename Aggregator>
    static auto send(const Message&, size_t, Aggregator*) -> bool {
        return false;
    }
};

/**
 * @brief Class to encapsulate a tasklist. This class functions as a central
 * mail-forwarding system in essence, redirecting messages to their
 * appropriate messages.
 *
 * @tparam MessageQueues
 */
template <MsgQueue... MessageQueues>
class QueueAggregator {
  public:
    using QueueTypes = std::variant<typename MessageQueues::Tag...>;
    using MessageTypes = std::variant<typename MessageQueues::Message...>;

    static constexpr size_t TaskCount = std::variant_size_v<QueueTypes>;

    static_assert(TaskCount > 0, "Must have at least one queue");

    QueueAggregator() : _handles() {}

    /**
     * @brief Register a queue handle with the task list
     *
     * @tparam Idx The index of this queue
     * @tparam Queue Type of the message queue
     * @param queue Handle to the queue
     */
    template <MsgQueue Queue>
    auto register_queue(Queue& queue) -> bool {
        constexpr auto idx = get_task_idx<Queue>();
        if (check_initialized<Queue>()) {
            // Not allowed to re-register
            return false;
        }
        std::get<idx>(_handles)._handle = &queue;
        return true;
    }

    /**
     * @brief Get the index of a queue, as generated by the Task List
     *
     * @tparam Message The type of the message
     * @return size_t A unique index for this message type
     */
    template <typename Queue>
    constexpr static auto get_task_idx() -> size_t {
        using Tag = typename Queue::Tag;
        return QueueTypes((Tag())).index();
    }

    /**
     * @brief Get the index of a queue, based on an individual message
     * definition. This deduction will ONLY work if the message is unique
     * to a specific queue (i.e. it is not sent to multiple tasks)
     */
    template <typename Message>
    constexpr static auto get_message_idx() -> size_t {
        return MessageTypes((Message())).index();
    }

    /**
     * @brief Send a message and automatically deduce the mailbox
     * to forward it to.
     *
     * @tparam Message The type of message to send
     * @tparam Tag The tag type of the queue to send to. This must be
     * provided by each queue type delcared for the QueueAggregator.
     * @param msg The message to send
     * @return true if the message could be sent, false otherwise
     */
    template <typename Tag, typename Message>
    auto send(const Message& msg, const Tag& tag = (Tag())) -> bool {
        static_cast<void>(tag);
        constexpr auto idx = get_task_idx<Tag>();
        return send_to<idx>(msg);
    }

    /**
     * @brief Send a message and automatically deduce the mailbox
     * to forward it to.
     *
     * @tparam Message The type of message to send
     * @param msg
     * @return true if the message could be sent, false otherwise
     */
    template <typename Message>
    auto send(const Message& msg) -> bool {
        constexpr auto idx = get_message_idx<Message>();
        return send_to<idx>(msg);
    }

    template <typename Message>
    auto send_to_address(const Message& msg, size_t address) -> bool {
        if (!(address < TaskCount)) {
            return false;
        }
        return send_helper<TaskCount>::send(msg, address, this);
    }

    /**
     * @brief Send a message
     *
     * @tparam Idx The index of the message to send to, as returned by
     *             \ref get_task_idx()
     * @tparam Message The type of message to send
     * @param msg The message to send
     * @return true if the message could be sent, false otherwise
     */
    template <size_t Idx, typename Message>
    auto send_to(const Message& msg) -> bool {
        // static_assert(Idx < TaskCount,
        //    "Invalid task index");
        if (!(Idx < TaskCount)) {
            return false;
        }
        if (std::get<Idx>(_handles)._handle == nullptr) {
            return false;
        }
        return std::get<Idx>(_handles)._handle->try_send(msg);
    }

  private:
    /**
     * @brief Wrapper class for holding a pointer to a queue with
     * a default nullptr value
     *
     * @tparam Queue type of queue to use
     */
    template <typename Queue>
    struct QueueHandle {
        QueueHandle() : _handle(nullptr) {}
        Queue* _handle;
    };

    template <typename Queue>
    [[nodiscard]] auto check_initialized() const -> bool {
        return std::get<get_task_idx<Queue>()>(_handles)._handle != nullptr;
    }

    // Handle for each of the tasks
    // Replace ptr with struct holding ptr
    std::tuple<QueueHandle<MessageQueues>...> _handles;
};

};  // namespace queue_aggregator
