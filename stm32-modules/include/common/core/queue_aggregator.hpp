/**
 * @file queue_aggregator.hpp
 * @brief Provides a templated type to aggregate queues
 */

#include <atomic>
#include <memory>
#include <optional>
#include <tuple>
#include <variant>

namespace queue_aggregator {

template <typename Q, typename Message = Q::Message, typename Tag = Q::Tag>
concept MsgQueue = requires(Q queue, Message msg, Tag tag) {
    { queue.try_send(msg) } -> std::same_as<bool>;
    { queue.try_send_from_isr(msg) } -> std::same_as<bool>;
    { queue.try_recv(&msg) } -> std::same_as<bool>;
    { queue.recv(&msg) } -> std::same_as<void>;
    { queue.has_message() } -> std::same_as<bool>;
};

// In order to provide runtime visitation on the tuple of handles,
// we utilize this helper struct...
template <size_t N>
struct SendHelper {
    /**
     * @brief Helper function to provide runtime resolution of index-based
     * queue send operations. The function recurses down the range of indices
     * available for a QueueAggregator, and checks whether the runtime-
     * provided index `idx` is a match. If that is the case, a constexpr
     * evaluation checks wither the type `Message` can be used to construct
     * the message type we want to send to. If yes, the message is sent;
     * otherwise, we return `false` to indicate that the message and index
     * were mismatched.
     * 
     * @tparam Message The message type to send
     * @tparam Aggregator Instantiation of the QueueAggregator class
     * @param msg The message to send
     * @param idx The queue index we want to send to; this should be derived
     *            from the `get_message_idx` or `get_task_idx` function
     *            provided by QueueAggregator
     * @param handle Handle to the Aggregator
     * @return true if the messsage was succesfully sent, false otherwise
     */
    template <typename Message, typename Aggregator>
    static auto send(const Message& msg, size_t idx, Aggregator* handle)
        -> bool {
        using VariantType =
            std::variant_alternative_t<N - 1,
                                       typename Aggregator::MessageTypes>;
        if (N - 1 == idx) {
            if constexpr (std::is_constructible_v<VariantType, Message>) {
                return handle->template send_to<N - 1>(msg);
            }
            // Can't send to this queue type
            return false;
        } else {
            return SendHelper<N - 1>::send(msg, idx, handle);
        }
    }
};

// Specialization for cases of N=0, in which case all functions return false
// to indicate a failure to resolve.
template <>
struct SendHelper<0> {
    template <typename Message, typename Aggregator>
    static auto send(const Message&, size_t, Aggregator*) -> bool {
        return false;
    }
};

/**
 * @brief Class to encapsulate a tasklist. This class functions as a central
 * mail-forwarding system in essence, redirecting messages to their
 * appropriate messages.
 *
 * @tparam MessageQueues
 */
template <MsgQueue... MessageQueues>
class QueueAggregator {
  public:
    using QueueTypes = std::variant<typename MessageQueues::Tag...>;
    using MessageTypes = std::variant<typename MessageQueues::Message...>;

    static constexpr size_t TaskCount = std::variant_size_v<QueueTypes>;

    static_assert(TaskCount > 0, "Must have at least one queue");

    QueueAggregator() : _handles() {}

    /**
     * @brief Register a queue handle with the task list
     *
     * @tparam Idx The index of this queue
     * @tparam Queue Type of the message queue
     * @param queue Handle to the queue
     */
    template <MsgQueue Queue>
    auto register_queue(Queue& queue) -> bool {
        constexpr auto idx = get_task_idx<Queue>();
        if (check_initialized<Queue>()) {
            // Not allowed to re-register
            return false;
        }
        std::get<idx>(_handles)._handle = &queue;
        return true;
    }

    /**
     * @brief Get the index of a queue, as generated by the Task List
     *
     * @tparam Message The type of the message
     * @return size_t A unique index for this message type
     */
    template <typename Queue>
    constexpr static auto get_task_idx() -> size_t {
        using Tag = typename Queue::Tag;
        return QueueTypes((Tag())).index();
    }

    /**
     * @brief Get the index of a queue, based on an individual message
     * definition. This deduction will ONLY work if the message is unique
     * to a specific queue (i.e. it is not sent to multiple tasks)
     */
    template <typename Message>
    constexpr static auto get_message_idx() -> size_t {
        return MessageTypes((Message())).index();
    }

    /**
     * @brief Send a message and automatically deduce the mailbox
     * to forward it to.
     *
     * @tparam Message The type of message to send
     * @tparam Tag The tag type of the queue to send to. This must be
     * provided by each queue type delcared for the QueueAggregator.
     * @param msg The message to send
     * @return true if the message could be sent, false otherwise
     */
    template <typename Tag, typename Message>
    auto send(const Message& msg, const Tag& tag = (Tag())) -> bool {
        static_cast<void>(tag);
        constexpr auto idx = get_task_idx<Tag>();
        return send_to<idx>(msg);
    }

    /**
     * @brief Send a message and automatically deduce the mailbox
     * to forward it to.
     *
     * @tparam Message The type of message to send
     * @param msg
     * @return true if the message could be sent, false otherwise
     */
    template <typename Message>
    auto send(const Message& msg) -> bool {
        constexpr auto idx = get_message_idx<Message>();
        return send_to<idx>(msg);
    }

    template <typename Message>
    auto send_to_address(const Message& msg, size_t address) -> bool {
        if (!(address < TaskCount)) {
            return false;
        }
        return SendHelper<TaskCount>::send(msg, address, this);
    }

  private:

    /**
     * @brief Internal function for sending a message
     *
     * @tparam Idx The index of the message to send to, as returned by
     *             \ref get_task_idx()
     * @tparam Message The type of message to send
     * @param msg The message to send
     * @return true if the message could be sent, false otherwise
     */
    template <size_t Idx, typename Message>
    auto send_to(const Message& msg) -> bool {
        // static_assert(Idx < TaskCount,
        //    "Invalid task index");
        if (!(Idx < TaskCount)) {
            return false;
        }
        if (std::get<Idx>(_handles)._handle == nullptr) {
            return false;
        }
        return std::get<Idx>(_handles)._handle->try_send(msg);
    }

    /**
     * @brief Wrapper class for holding a pointer to a queue with
     * a default nullptr value
     *
     * @tparam Queue type of queue to use
     */
    template <typename Queue>
    struct QueueHandle {
        QueueHandle() : _handle(nullptr) {}
        Queue* _handle;
    };

    template <typename Queue>
    [[nodiscard]] auto check_initialized() const -> bool {
        return std::get<get_task_idx<Queue>()>(_handles)._handle != nullptr;
    }

    // SendHelper uses the internal send_to function...
    template <size_t N>
    friend struct SendHelper;

    // Handle for each of the tasks
    // Replace ptr with struct holding ptr
    std::tuple<QueueHandle<MessageQueues>...> _handles;
};

};  // namespace queue_aggregator
